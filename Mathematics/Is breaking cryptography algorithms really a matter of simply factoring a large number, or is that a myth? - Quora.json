{
    "title": "Is breaking cryptography algorithms really a matter of simply factoring a large number, or is that a myth? - Quora",
    "tags": [
        "Cryptography"
    ],
    "response": [
        {
            "author_info": {
                "name": "Buddha Buck",
                "href": "/profile/Buddha-Buck"
            },
            "answer_text": "It\u2019s a myth with some truth to it, enough to be a concern, but not enough to warrant the level press coverage that claims that quantum computers can quickly factory large numbers therefore all cryptography is broken forever. In truth, there are a tremendous number of cryptography algorithms which have nothing to do with the factors of large numbers, and are thus immune to attacks based on factoring. Many of these have no known attack that is better than simply trying every possible key. They are perfectly good cryptographic algorithms, and are used all the time. A small handful of these (with names like DES, 3DES, ARCFOUR, AES, Camellia, RC2, IDEA, and SEED) are used for the vast majority of encrypted communication across the internet. Some of those shouldn\u2019t be (DES, for instance, was reasonably good when it was first published in 1975, but the intervening 40 years of computer hardware improvements and cryptoanalysis have made it a \u201cbroken cypher\u201d for over a decade now), but most of them are good, fast, unbroken crypto algorithms. They all have a practical problem, in that both ends of the communication need to use the same key, and using the same key too much can reveal too much information to a third party, potentially allowing them to break the encryption. This means that in order to be secure, a new, unique, random key needs to be used for each connection over the internet. And this new key has to be agreed to by both sides, who have to negotiate this new key on an insecure channel. This problem (\u201ckey exchange\u201d) was first solved in the 1970\u2019s by researchers in the US (Diffie, Hillman, Rivest, Shamir, Adleman, others) and in the UK (in secret by GHCQ). These methods involved mathematical problems, like factoring or discrete logarithm, which are easy to do in one direction but hard to do in the other direction. For instance, given two prime numbers [math]p, q[/math], it is easy to find a pair of numbers [math]e, d[/math] such that [math]m^{ed} \\equiv m \\pmod{pq}[/math], but it is hard, given [math]pq[/math] and [math]e[/math] to find a matching [math]d[/math]. Or for a prime number [math]p[/math] and small number [math]g[/math], it is easy to find [math]g^{ab}\\bmod p[/math] if you are given [math]a[/math] and [math]g^b\\bmod p[/math](or [math]b[/math] and [math]g^a\\bmod p[/math]), but it is hard given [math]g^a\\bmod p, g^b\\bmod p[/math]). The algorithm invented by Rivest, Shamir, and Adleman (RSA) is extremely well-known, well-studied, and trusted. It allows anyone to publicly post a \u201cpublic key\u201d, [math](pq, e)[/math] that can be used to encrypt any message such that only someone who knows the \u201cprivate key\u201d [math](pq, d)[/math] can decrypt. It also allows someone to \u201csign\u201d something using the \u201cprivate key\u201d such that anyone knowing the \u201cpublic key\u201d can verify it was signed by that private key. Only one person needs to know the private key, and anyone can know the public key, and the communication is secure. And slow\u2026 which is why RSA isn\u2019t generally used to secure huge amounts of data, but rather a symmetric key for a fast secure algorithm that is used to encrypt the bulk of the data. But RSA is dependent on factoring being \u201chard\u201d. It is easy to find the private key [math](pq, d)[/math] if you know [math]p, q[/math] and [math]e[/math], which is easy to do if you can easily factor [math]pq[/math] from the public key. But RSA isn\u2019t the only public key system known, and not all depend on factoring being hard. It is probably one of the most studied, and one of the most used, however. If factoring became easy, then until all the appropriate protocols were changed to say \u201cDon\u2019t use RSA (or Rabin, or\u2026), use ElGamal, NTRU, RLWE, Cramer-Shroup, etc instead\u201d (and good implementations of ElGamal, NTRU, RLWE, etc are available). Right now, there are efficient algorithms for factoring (and discrete logarithms) for quantum computers. So the security of RSA (and DH) have gone from the assumption that factoring (and discrete logarithms) are hard to the assumption that building large quantum computers is hard. So far, that assumption has proven correct (the record for largest number factored by a quantum computer? 56153, factored in 2012). So, if we could \u201csimply\u201d factor numbers, a lot of currently used cryptography protocols would have problem, but those protocols are designed to be able to switch to different algorithms that aren\u2019t broken by easy factoring. ",
            "date": "Answered December 8, 2018",
            "views": "423",
            "upvotes": " View 5 Upvoters",
            "upvoters": [
                {
                    "user_id": "Travis Brauer",
                    "user_href": "/profile/Travis-Brauer"
                },
                {
                    "user_id": "Luk\u00e1\u0161 Kubacki",
                    "user_href": "/profile/Luk\u00e1\u0161-Kubacki"
                },
                {
                    "user_id": "Hill Tse",
                    "user_href": "/profile/Hill-Tse"
                },
                {
                    "user_id": "Paul Bissex",
                    "user_href": "/profile/Paul-Bissex-1"
                },
                {
                    "user_id": "David Joyce",
                    "user_href": "/profile/David-Joyce-11"
                }
            ]
        },
        {
            "author_info": {
                "name": "Steven J Owens",
                "href": "/profile/Steven-J-Owens"
            },
            "answer_text": "Yes and no. Breaking a cryptographic algorithm would mean not merely figuring out how to decrypt some individual file, but rather finding a fundamental flaw in the cryptographic math of the algorithm that, once discovered, makes it significantly easier to reverse-engineer the numbers that the algorithm uses to encrypt things. Decrypting a file that you don\u2019t have the key for can be done in a number of ways. Factoring large primes is probably the least efficient approach, but it is the ultimate resort. The difficulty in factoring large numbers is what makes cryptography work, what makes it unfeasibly hard to descramble the data by just running the math in reverse. \u201cBreaking\u201d the encryption of some specific piece of data, i.e. decrypting it without the necessary key (a very large number kept private by the person who encrypted it) can be done by factoring the large numbers involved in encrypting the data, but most attempts will look for ways to sidestep this challenge. Most exploits and cryptographic flaws are found in the implementation of the cryptography rather than in a flaw in the math behind the cryptography. Software development in general is complex, crypto math and algorithms are complex; multiply that complexity together and you have a very, very hard job to do, and it\u2019s very easy to make a mistake in either the design or implementation of it. As an example, I recall reading about an exploit of wireless security that relied on finding a way to cause the crypto software to repeat thousands of \u201chandshake\u201d attempts in a very brief period of time. The handshake is the initial negotiation between two sides of a cryptographic communication. These thousands of handshake attempts in turn allowed the attacker to build up enough data to look for patterns in the numbers, and from that reverse engineer the number used to encrypt/decrypt. This difficulty in designing crypto systems is one reason why the modern cryptography community considers crypto systems whose details are kept secret to be worthless. The probability that keeping the algorithm secret will prevent the designer from discovering a flaw is much greater than the probability that publishing the algorithm will help a bad actor discover the flaw before the designer\u2019s peers in the crypto community do. Occasionally crypto is broken because of a new development in math that makes invalid some assumption about what calculations are feasible. The classic example is finding a new, more efficient way to factor large primes that makes invalid the assumption that factoring the primes will be too computationally expensive. But more likely it\u2019s some less obvious aspect of the fundamental mathematical theory behind the crypto math. Then we get to brute force attacks. Even here, there are smarter brute force attacks, rather than simply trying to factor large primes. One of the most common is the \u201cdictionary attack\u201d; if you have a copy of the encrypted data (rather than interacting with some system that has the data, which might limit the number of attempts you can try) you can attempt to reverse engineer the number used in the encryption (scrambling) step by simply attempting to run the decryption algorithm again and again, with a large number of possible keys, and seeing if the results make sense. Bear in mind that in many systems the \u201cnumber\u201d is actually derived from a password or pass phrase of some sort. Text in a computer is encoded using numbers \u2014 for example, \u201cpassword\u201d encoded in ASCII is 112 97 115 115 119 111 114 100 (p = 112, a = 97, s = 115, s = 115, w = 119, o = 111, r = 114, d = 100), which you could also just treat as a single, long number, like 112097115115119111114 \u2014 so many systems ask for a password or phrase and use the number encoding of it as the key, or at least as the start for generating a more complicated number to use as a key. Usually you try a number of \u201ceducated guesses\u201d first, starting with guesses specific to the situation \u2014 somebody\u2019s birthday, or their spouse\u2019s birthday, their mother\u2019s maiden name, etc. Then you try more general educated guesses, like commonly used passwords. The words \u201cpassword\u201d and \u201csecret\u201d are two of the most common\u2026 as are swear words and a number of other things. When you run out of those, then you just start trying every word in the dictionary, and so forth. Okay, we\u2019ve tried the easier ways and they didn\u2019t work, now we\u2019re down to factoring large numbers. Elliptical Curve encryption is all the rage these days, but first generation modern crypto systems like RSA and Diffie-Hellman key exchange used large prime numbers and one-way functions (also called trapdoor functions). Prime numbers and one-way functions have the interesting quality that you can\u2019t simply run the calculation in reverse to figure out the missing numbers. Okay, technically you can run the calculation in reverse, it\u2019s just a lot more work than running it forward. I mean, a lot lot more. No, more than that. So much more that people consider it impossible in practical terms. Instead, you have to guess at the input numbers, try running the calculation forward with those guesses, and see if it works. Use large enough prime numbers and this takes a long enough time that you can generally count on your secrets remaining secret, at least until they\u2019re irrelevant (many years later). Note: Elliptical curve encryption uses a different sort of calculation that has to do with finding a point on an elliptical curve by successive calculation steps, but it also has that same hard-to-run-in-reverse quality. I took a stab at explaining it here: Steven J Owens's answer to What is elliptic cryptography used in the blockchain? So you could, in theory, try to decrypt something by trying a brute force attack that feeds every possible prime number into the algorithm. But that\u2019s almost certainly going to be more computationally expensive than other approaches. That is, after all, the whole point of the design of crypto systems. ",
            "date": "Updated October 15, 2020",
            "views": "163",
            "upvotes": " View 2 Upvoters",
            "upvoters": [
                {
                    "user_id": "Quora User",
                    "user_href": "/profile/Aaron-Da-SIlva-4"
                },
                {
                    "user_id": "Soumik Rakshit",
                    "user_href": "/profile/Soumik-Rakshit-3"
                }
            ]
        }
    ]
}
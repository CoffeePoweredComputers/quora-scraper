{
    "title": "What is the use of MOBX? - Quora",
    "tags": [
        "Computer Networking",
        "Android Applications",
        "The Internet",
        "Computers",
        "Software and Applications",
        "Programming Languages",
        "Technology",
        "Web Development",
        "Mobile Applications"
    ],
    "response": [
        {
            "author_info": {
                "name": "Shiv Chnadra Jha",
                "href": "/profile/Shiv-Chnadra-Jha"
            },
            "answer_text": "MobX is a battle tested library that makes state management simple and scalable by transparently applying functional reactive programming (TFRP). The philosophy behind MobX is very simple: Anything that can be derived from the application state, should be derived. Automatically. which includes the UI, data serialization, server communication, etc.  React and MobX together are a powerful combination. React renders the application state by providing mechanisms to translate it into a tree of renderable components. MobX provides the mechanism to store and update the application state that React then uses. Both React and MobX provide an optimal and unique solutions to common problems in application development. React provides mechanisms to optimally render UI by using a virtual DOM that reduces the number of costly DOM mutations. MobX provides mechanisms to optimally synchronize application state with your React components by using a reactive virtual dependency state graph that is only updated when strictly needed and is never stale. Core concepts MobX has only a few core concepts. The following snippets can be tried online using codesandbox example. Observable state Egghead.io lesson 1: observable & observer MobX adds observable capabilities to existing data structures like objects, arrays and class instances. This can simply be done by annotating your class properties with the @observable decorator (ES.Next). import { observable } from \"mobx\"\u00a0\u00a0class Todo {\u00a0    id = Math.random()\u00a0    @observable title = \"\"\u00a0    @observable finished = false\u00a0}\u00a0Using observable is like turning a property of an object into a spreadsheet cell. But unlike spreadsheets, these values can be not only primitive values, but also references, objects and arrays. If your environment doesn't support decorator syntax, don't worry. You can read here about how to set them up. Or you can skip them altogether, as MobX can be used fine without decorator syntax, by leveraging the decorate utility. Many MobX users do prefer the decorator syntax though, as it is slightly more concise. import { decorate, observable } from \"mobx\"\u00a0\u00a0class Todo {\u00a0    id = Math.random()\u00a0    title = \"\"\u00a0    finished = false\u00a0}\u00a0decorate(Todo, {\u00a0    title: observable,\u00a0    finished: observable\u00a0})\u00a0Computed values With MobX you can define values that will be derived automatically when relevant data is modified. By using the @computed decorator or by using getter / setter functions when using (extend)Observable (Of course, you can use decorate here again as alternative to the @ syntax). class TodoList {\u00a0    @observable todos = []\u00a0    @computed get unfinishedTodoCount() {\u00a0        return this.todos.filter(todo => !todo.finished).length\u00a0    }\u00a0}\u00a0MobX will ensure that unfinishedTodoCount is updated automatically when a todo is added or when one of the finished properties is modified. Computations like these resemble formulas in spreadsheet programs like MS Excel. They update automatically and only when required. ",
            "date": "Answered October 21, 2019",
            "views": "25",
            "upvotes": " Answer requested by H K Bhanuprakash"
        },
        {
            "author_info": {
                "name": "Nitor Infotech",
                "href": "/profile/Nitor-Infotech-2"
            },
            "answer_text": "Introduction MobX is a battle tested library that makes state management simple and scalable by transparently applying functional reactive programming (TFRP). The philosophy behind MobX is very simple: Anything that can be derived from the application state, should be derived. Automatically. which includes the UI, data serialization, server communication, etc.  React and MobX together are a powerful combination. React renders the application state by providing mechanisms to translate it into a tree of renderable components. MobX provides the mechanism to store and update the application state that React then uses. Both React and MobX provide an optimal and unique solutions to common problems in application development. React provides mechanisms to optimally render UI by using a virtual DOM that reduces the number of costly DOM mutations. MobX provides mechanisms to optimally synchronize application state with your React components by using a reactive virtual dependency state graph that is only updated when strictly needed and is never stale. Core concepts MobX has only a few core concepts. The following snippets can be tried online using codesandbox example. Observable state Egghead.io lesson 1: observable & observer (https://egghead.io/lessons/javascript-sync-the-ui-with-the-app-state-using-mobx-observable-and-observer-in-react) MobX adds observable capabilities to existing data structures like objects, arrays and class instances. This can simply be done by annotating your class properties with the @observable decorator (ES.Next). import { observable } from \"mobx\"\u00a0\u00a0class Todo {\u00a0    id = Math.random()\u00a0    @observable title = \"\"\u00a0    @observable finished = false\u00a0}\u00a0Using observable is like turning a property of an object into a spreadsheet cell. But unlike spreadsheets, these values can be not only primitive values, but also references, objects and arrays. If your environment doesn't support decorator syntax, don't worry. You can read here about how to set them up. Or you can skip them altogether, as MobX can be used fine without decorator syntax, by leveraging the decorate utility. Many MobX users do prefer the decorator syntax though, as it is slightly more concise. import { decorate, observable } from \"mobx\"\u00a0\u00a0class Todo {\u00a0    id = Math.random()\u00a0    title = \"\"\u00a0    finished = false\u00a0}\u00a0decorate(Todo, {\u00a0    title: observable,\u00a0    finished: observable\u00a0})\u00a0Computed values Egghead.io lesson 3: computed values (https://egghead.io/lessons/javascript-derive-computed-values-and-manage-side-effects-with-mobx-reactions) With MobX you can define values that will be derived automatically when relevant data is modified. By using the @computed decorator or by using getter / setter functions when using (extend)Observable (Of course, you can use decorate here again as alternative to the @ syntax). class TodoList {\u00a0    @observable todos = []\u00a0    @computed get unfinishedTodoCount() {\u00a0        return this.todos.filter(todo => !todo.finished).length\u00a0    }\u00a0}\u00a0MobX will ensure that unfinishedTodoCount is updated automatically when a todo is added or when one of the finished properties is modified. Computations like these resemble formulas in spreadsheet programs like MS Excel. They update automatically and only when required. Reactions Egghead.io lesson 9: custom reactions Reactions are similar to a computed value, but instead of producing a new value, a reaction produces a side effect for things like printing to the console, making network requests, incrementally updating the React component tree to patch the DOM, etc. In short, reactions bridge reactive and imperative programming. React components Egghead.io lesson 1: observable & observer If you are using React, you can turn your (stateless function) components into reactive components by simply adding the observer function / decorator from the mobx-react package onto them. import React, { Component } from \"react\"\u00a0import ReactDOM from \"react-dom\"\u00a0import { observer } from \"mobx-react\"\u00a0\u00a0@observer\u00a0class TodoListView extends Component {\u00a0    render() {\u00a0        return (\u00a0            <div>\u00a0                <ul>\u00a0                    {this.props.todoList.todos.map(todo => (\u00a0                        <TodoView todo={todo} key={todo.id} />\u00a0                    ))}\u00a0                </ul>\u00a0                Tasks left: {this.props.todoList.unfinishedTodoCount}\u00a0            </div>\u00a0        )\u00a0    }\u00a0}\u00a0\u00a0const TodoView = observer(({ todo }) => (\u00a0    <li>\u00a0        <input\u00a0            type=\"checkbox\"\u00a0            checked={todo.finished}\u00a0            onClick={() => (todo.finished = !todo.finished)}\u00a0        />\u00a0        {todo.title}\u00a0    </li>\u00a0))\u00a0\u00a0const store = new TodoList()\u00a0ReactDOM.render(<TodoListView todoList={store} />, document.getElementById(\"mount\"))\u00a0observer turns React (function) components into derivations of the data they render. When using MobX there are no smart or dumb components. All components render smartly but are defined in a dumb manner. MobX will simply make sure the components are always re-rendered whenever needed, but also no more than that. So the onClick handler in the above example will force the proper TodoView to render, and it will cause the TodoListView to render if the number of unfinished tasks has changed. However, if you would remove the Tasks left line (or put it into a separate component), the TodoListView will no longer re-render when ticking a box. You can verify this yourself by changing the JSFiddle. Custom reactions Custom reactions can simply be created using the autorun, reaction or when functions to fit your specific situations. For example the following autorun prints a log message each time the amount of unfinishedTodoCount changes: autorun(() => {\u00a0    console.log(\"Tasks left: \" + todos.unfinishedTodoCount)\u00a0})\u00a0What will MobX react to? Why does a new message get printed each time the unfinishedTodoCount is changed? The answer is this rule of thumb: MobX reacts to any existing observable property that is read during the execution of a tracked function. For an in-depth explanation about how MobX determines to which observables needs to be reacted, check understanding what MobX reacts to. Actions Egghead.io lesson 5: actions Unlike many flux frameworks, MobX is unopinionated about how user events should be handled. This can be done in a Flux like manner.Or by processing events using RxJS.Or by simply handling events in the most straightforward way possible, as demonstrated in the above onClick handler.In the end it all boils down to: Somehow the state should be updated. After updating the state MobX will take care of the rest in an efficient, glitch-free manner. So simple statements, like below, are enough to automatically update the user interface. There is no technical need for firing events, calling a dispatcher or what more. A React component in the end is nothing more than a fancy representation of your state. A derivation that will be managed by MobX. store.todos.push(new Todo(\"Get Coffee\"), new Todo(\"Write simpler code\"))\u00a0store.todos[0].finished = true\u00a0Nonetheless, MobX has an optional built-in concept of actions. Read this section as well if you want to know more about writing asynchronous actions. It's easy! Use them to your advantage; they will help you to structure your code better and make wise decisions about when and where state should be modified. ",
            "date": "Answered November 4, 2019",
            "views": "186",
            "upvotes": " Answer requested by H K Bhanuprakash"
        }
    ]
}